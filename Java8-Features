ğŸŒŸ ğŸ” âš¡ ğŸ§© ğŸ§  âœ… ğŸ¯ ğŸŒ ğŸ“Œ ğŸ†š ğŸ”¥ ğŸš¦ ğŸ§ª ğŸ“¦ âš™ï¸ ğŸš€ ğŸ” ğŸ”§ ğŸ ğŸ“ ğŸ” â¡ï¸ âŒ ğŸ§­ ğŸ”¹ ğŸ¨ ğŸ§± ğŸ“± â™¿ â›” ğŸ’¡ ğŸ“¡ â™»ï¸ ğŸ”— ğŸ‘‹ ğŸ“š 

ğŸŒ Java 8 features

ğŸ¯ 1. Lambda Expression
ğŸ¯ 2. Funtional Interface
ğŸ¯ 3. Method Reference
ğŸ¯ 4. Streams API
ğŸ¯ 5. Optional classes
ğŸ¯ 6. Comparator and Comparable

ğŸ¯ 1. Lambda Expression
âœ… A Lambda expression is a simple piece of code that takes in parameters and produces a result.
âœ… It's primarily used with functional interfaces, which are interfaces with just one abstract method and n number of static or default methods.
âœ… Unlike traditional methods, Lambda expressions don't have a method name, return type, or explicit parameter types.
âœ… They're typically defined inline when creating an instance of a functional interface.
âœ… Java automatically infers parameter types based on the context, making Lambda expressions concise and easy to use.

ğŸ§  Syntax: int sum1 = (a, b) -> (a + b)

ğŸ“Œ Example:
ğŸ”¹ //Functional Interface
ğŸ”¹ Interface Addable { int add(int a, int b);
ğŸ”¹ 
ğŸ”¹ public class LambdaExpression{
ğŸ”¹   public static void main(String[] args){
ğŸ”¹     Addable add = (a, b) -> (a + b);
ğŸ”¹     System.out.println(add.add(20, 20); //output: 40
ğŸ”¹    }
ğŸ”¹ }

ğŸ’¡ 'Function' is a built-in-functional interfaces provided by Java.
ğŸ’¡ They come with an abstract method called apply(), which simplifies the process for developers by eliminating the need to create custom functional interfaces.

ğŸ¯ 2. Funtional Interface
âœ… A functional interface is characterized by having only one abstract method, though it can also indlcude any number of default or static methods.
âœ… Function interfaces, also known as Single Abstract Method interfaces, are a addition to Java 8, aimed at enabling functional programming
âœ… Functional interface can also have methods of Object class

ğŸ“Œ Example:
ğŸ”¹ //Functional interface
ğŸ”¹ interface shape{ void draw(); }
ğŸ”¹ 
ğŸ”¹ class Rectangle implements shape{
ğŸ”¹  Rectangle() { }
ğŸ”¹  public void draw() { System.out.println("I am Rectangle from Rectangle class"); }
ğŸ”¹ }
ğŸ”¹  public class FunctionalInterfaceDemo {
ğŸ”¹   public static void main(String[] args){
ğŸ”¹     Rectangle rectangle = new Rectangle();
ğŸ”¹     rectangle.draw(); //print "I am Rectangle from Rectangle class"
ğŸ”¹     shape rectangleLambda = () -> { System.out.println("I am in Rectangle"); };
ğŸ”¹     rectangle.draw(); //print "I am in Rectangle"

ğŸ¯ 3. Method Reference
âœ… In Java 8, method references provide a concise way to refer to methods or constructors without actually invoking them.
âœ… They act as shorthand for lambda expressions, allowing you to pass methods as arguments to functional interfaces.
âœ… For example, the following lambda expression takes a string input and converts it to lowercase using a built-in method from the String class.
    ğŸ”¹ Function<String, String> function = (str) -> str.toLowerCase();
    ğŸ”¹ System.out.println(function.apply("LAMBDA EXPRESSION");
âœ… You can replace the above code with method reference as shown below.
    ğŸ”¹ Function<String, String> function = String::toLowerCase();
    ğŸ”¹ System.out.println(function.apply("LAMBDA EXPRESSION");

ğŸ’¡ There are basically 4 types of method references
ğŸš€ 1. Static Method: ClassNae::staticMethodName
ğŸš€ 2. Reference to an instance method of a particular object: object::methodName
ğŸš€ 3. Reference to an instance method of a Class Type: ClassName::methodName
ğŸš€ 4. Reference to a constructor: ClassName::new

ğŸ¯ 4. Streams API
âœ… Streams are used ot process collection of objects and facilitates various operations such as filtering, sorting, mapping and collecting data from a collection.
âœ… These operations can be chained together to create a pipeline for querying and processing the data.
âœ… Java 8 introduced the Stream API as a significant addition to the Collections API in java.util.stream package.
âœ… Stream APIs are extremenly userful when dealing with large collection of data, due to their to leverage optimizations like lazy evaluation and parallel processing.
âœ… By eliminating the need of explicitly defining loop or conditional statements developers can now use built-in-methods like filter,sorted etc.
âœ… This not only reduces the effort required for complex implementations and minimizes the risk of bugs, but also improves the clarity and understandability of the code.

ğŸ“Œ Example:
ğŸ”¹ //10. Given an array find the sum of unique elements
ğŸ”¹ //Input: int[] arr = {1,6,7,8,1,1,8,8,7}
ğŸ”¹ //output: 22
ğŸ”¹ System.out.println("Given an array find the sum of unique elements");
ğŸ”¹ int[] arr = {1,6,7,8,1,1,8,8,7};
ğŸ”¹ int sum = Arrays.stream(arr).distinct().sum();
ğŸ”¹ System.out.println(sum);

ğŸ’¡ Common Operations
ğŸš€ Filtering : filter, distict
ğŸš€ Mapping: map
ğŸš€ Sorting: sorted
ğŸš€ Aggregating: count, min, max, sum, average
ğŸš€ Iterating: forEach
ğŸš€ Finding: findFirst, findAny

ğŸ¯ 5. Optional classes
âœ… Java introduced the Optional class in java.util package to improve the management of null values.
âœ… Traditionally, null signifies the absence of a value, but this practice frequently results in NullPointerExceptions (NPEs) when not handled correctly.
âœ… These exceptions can be difficult to debug and may lead to runtime failures in Java applications.

ğŸ“Œ Example:
ğŸ”¹ Optional<String> name = Optional.of("John"); // Non-null value
ğŸ”¹ Optional<String> empty = Optional.empty(); // No value
ğŸ”¹ Optional<String> maybeName = Optional.ofNullable(null); // Nullable value

ğŸ”¹ if(maybeName.isPresent()) { System.out.println(maybeName.get()); }
ğŸ”¹ name.ifPresent(n -> System.out.println("Hello, " + n);

ğŸ¯ 6. Comparator and Comparable
âœ… Both Comparator and Comparable are interfaces in Java used for comparing objects, but they serve different purpose.

ğŸ§  Comparable Interface
âœ… The Comparable interface is used to impose a natural ordering on the objects of a class.
âœ… If a class implements Comparable, it means that its objects can be ordered automatically.
âœ… The class implementing Comparable must override the compareTo(Object obj) method that takes a single parameter, which compares this object with another 
    object of the same type and returns a negative integer, zero, or a positive integer depending on whether this object is less than, equal to, or greater
    than the other object, respectively.
âœ… Comparable is usually used when you want to define a default sorting order for objects of a class.
âœ… When you call sorting methods like Collections.sort() on a list of objects that implement Comparable, the sort method internally uses the compareTo method
    to determine the ordering of the objects.
âœ… You don't need to call compareTo yourself; it's invoked automatically by the sorting algorithm implemented in Collections.sort()

ğŸ“Œ For example, the String class and the wrapper classes (Integer, Double, etc.) implement Comparable to enable natural ordering.
ğŸ”¹ import java.util.*;
ğŸ”¹ 
ğŸ”¹ // âœ… Step 1: Create a class that implements Comparable
ğŸ”¹ class Student implements Comparable<Student> {
ğŸ”¹     private String name;
ğŸ”¹     private int marks;
ğŸ”¹ 
ğŸ”¹     // Constructor
ğŸ”¹     public Student(String name, int marks) {
ğŸ”¹         this.name = name;
ğŸ”¹         this.marks = marks;
ğŸ”¹     }
ğŸ”¹ 
ğŸ”¹     // âœ… Step 2: Override the compareTo() method to define natural ordering
ğŸ”¹     @Override
ğŸ”¹     public int compareTo(Student other) {
ğŸ”¹         // Sort in ascending order based on marks
ğŸ”¹         return Integer.compare(this.marks, other.marks);
ğŸ”¹         // If descending order is needed: return Integer.compare(other.marks, this.marks);
ğŸ”¹     }
ğŸ”¹ 
ğŸ”¹     // For printing student details
ğŸ”¹     @Override
ğŸ”¹     public String toString() {
ğŸ”¹         return name + " - " + marks;
ğŸ”¹     }
ğŸ”¹ }

ğŸ”¹ public class ComparableExample {
ğŸ”¹     public static void main(String[] args) {
ğŸ”¹         // âœ… Step 3: Create a list of students
ğŸ”¹         List<Student> students = new ArrayList<>();
ğŸ”¹         students.add(new Student("Alice", 85));
ğŸ”¹         students.add(new Student("Bob", 92));
ğŸ”¹         students.add(new Student("Charlie", 78));
ğŸ”¹ 
ğŸ”¹         // âœ… Step 4: Sort the list using Collections.sort() which internally uses compareTo()
ğŸ”¹         Collections.sort(students);
ğŸ”¹ 
ğŸ”¹         // âœ… Step 5: Print the sorted list
ğŸ”¹         System.out.println("Students sorted by marks (ascending):");
ğŸ”¹         for (Student s : students) {
ğŸ”¹             System.out.println(s);
ğŸ”¹         }
ğŸ”¹     }
ğŸ”¹ }
ğŸ”¹ // ======== output======
ğŸ”¹ Students sorted by marks (ascending):
ğŸ”¹ Charlie - 78
ğŸ”¹ Alice - 85
ğŸ”¹ Bob - 92

ğŸ§  Comparator Interface:
âœ… The Comparator interface is used to define custom comparison logic for objects that do not implement Comparable or when you want to define multiple ways of comparing objects. 
âœ… The Comparator interface defines a single method called compare(Object o1, Object o2), which compares two objects and returns a negative integer, zero, or 
    a positive integer depending on whether the first object is less than, equal to, or greater than the second object, respectively.
âœ… Using a Comparator allows you to define multiple ways of comparing objects, each with its own criteria. 
âœ… This flexibility is especially useful when you need to sort objects in different ways depending on the context or user preferences. 
âœ… Implementing the Comparable interface requires modifying the class itself to provide a natural ordering. 
    But if you cannot modify the class (e.g., itâ€™s a third-party library or part of the Java core classes), using a Comparator allows you to define ordering externally.
âœ… Comparator instances can be passed to sorting methods like Collections.sort() or Arrays.sort() to sort objects based on the defined criteria.

ğŸ“Œ Example:

ğŸ”¹ import java.util.ArrayList;
ğŸ”¹ import java.util.Collections;
ğŸ”¹ import java.util.Comparator;
ğŸ”¹ import java.util.List;

ğŸ”¹ public class ComparatorDemo {

ğŸ”¹   public static void main(String[] args) {

ğŸ”¹         List<Employee> empList = new ArrayList<>();
ğŸ”¹         empList.add(new Employee(2, "Manoj", 56000));
ğŸ”¹         empList.add(new Employee(4, "Anuj", 30000));
ğŸ”¹         empList.add(new Employee(1, "Vijay", 40000));
ğŸ”¹         empList.add(new Employee(3, "Venu", 74000));
ğŸ”¹ 
ğŸ”¹         // Sort employees by name
ğŸ”¹         Collections.sort(empList, new NameCompare());
ğŸ”¹         System.out.println("Sorted by name:");
ğŸ”¹         System.out.println(empList);
ğŸ”¹ 
ğŸ”¹         // Sort employees by salary
ğŸ”¹         Collections.sort(empList, new Comparator<Employee>() 
ğŸ”¹         {
ğŸ”¹             public int compare(Employee e1 , Employee e2)
ğŸ”¹             {
ğŸ”¹                 return (int)(e1.getSalary() - e2.getSalary());
ğŸ”¹             }
ğŸ”¹         });
ğŸ”¹         System.out.println("\nSorted by salary:");
ğŸ”¹         System.out.println(empList);
ğŸ”¹     }
ğŸ”¹ }

ğŸ”¹ class Employee {
ğŸ”¹     private int empId;
ğŸ”¹     private String name;
ğŸ”¹     private double salary;
ğŸ”¹ 
ğŸ”¹     public Employee(int empId, String name, double salary) {
ğŸ”¹         this.empId = empId;
ğŸ”¹         this.name = name;
ğŸ”¹         this.salary = salary;
ğŸ”¹     }

ğŸ”¹     public int getEmpId() {
ğŸ”¹         return empId;
ğŸ”¹     }

ğŸ”¹     public String getName() {
ğŸ”¹         return name;
ğŸ”¹     }

ğŸ”¹     public double getSalary() {
ğŸ”¹         return salary;
ğŸ”¹     }
ğŸ”¹ 
ğŸ”¹     public String toString() {
ğŸ”¹         return "\n[ Emp Id = " + empId + " || Name = " + name + " || Salary = " + salary + " ]";
ğŸ”¹     }
ğŸ”¹ }

ğŸ”¹ // Comparator to compare employees by name
ğŸ”¹ class NameCompare implements Comparator<Employee> {
ğŸ”¹     public int compare(Employee e1, Employee e2) {
ğŸ”¹         return e1.getName().compareTo(e2.getName());
ğŸ”¹     }
ğŸ”¹ }

ğŸ’¡ Letâ€™s unserstand the above code.

ğŸš€ NameCompare Comparator: 
      The NameCompare class implements the Comparator<Employee> interface to compare Employee objects based on their names. 
      It overrides the compare method to compare the names of two Employee objects using the compareTo method of String.

ğŸš€ Main Method: 
      In the main method, a list empList of Employee objects is created and populated with employee data.
      The Collections.sort method is called twice to sort the empList:

ğŸš€ First, itâ€™s sorted using the NameCompare comparator to sort employees by name.
      Then, itâ€™s sorted using an anonymous Comparator<Employee> implementation to sort employees by salary.

ğŸš€ Inside this anonymous implementation, the compare method compares two Employee objects based on their salaries.
