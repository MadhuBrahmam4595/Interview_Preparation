🌟 🔁 ⚡ 🧩 🧠 ✅ 🎯 🌐 📌 🆚 🔥 🚦 🧪 📦 ⚙️ 🚀 🔍 🔧 🎁 📁 🔐 ➡️ ❌ 🧭 🔹 🎨 🧱 📱 ♿ ⛔ 💡 📡 ♻️ 🔗 👋 📚 

Chapters:
🧠 1. SB Core
🧠 2. SB Data JPA
🧠 3. SB MongoDB
🧠 4. SB Web MVC
🧠 5. SB E-Mail
🧠 6. SB Batch Processing
🧠 7. SB REST (Provider & Consumer)

Notes:
************************************************************* CHAPTER 1. SB CORE ******************************************************************************

✅ SB is an Abstract Maven Project also called as Parent Maven Project (i.e. A project with partial code).
✅ SB provides AUTO CONFIGURATION which means reduce common lines of code in application which is writtern by programmers and handle jars with version management.
  (i.e. Providing configuration code XML / Java and maintaining all jars required for Project Parent Jars + Child Jars).
✅ Here programmer will not write configuration code but need to give input data using 
    🚀 a) Properties File (application.properties)   🚀 b) YAMAL File (application.yml)
✅ SB supports end to end process that is called
    🚀 Coding -> Unit testing -> Version control -> Build -> Deployment -> Client Integration
✅ SB application is a service provider app which can be integrated with any UI client like Android, Angular UI, Any 3rd party apps, web apps using Rest and JMS.
✅ SB supports two build tools 
    🚀 1) MAVEN      🚀 2) GRADEL
✅ SB supports three embeded servers 
    🚀 1) Apache Tomcat (default)       🚀 2) JBoss Jetty       🚀 3) Undertow
✅ SB supports three embeded databases
    🚀 1) H2      🚀 2) HSQL DB       🚀 3) Apache Derby
✅ SB STARTER CLASS: It is a main method class used to start our app. It's entry point in execution. Even for both stand alone and web application.

🧠 SB RUNNERS:
**************
✅ A Runner is an auto-executable component which is called by container on application startup only once.
✅ In this concept is used to execute any login (code) one time when application is started.
  Types of Runners
    🚀 1. COMMANDLINE RUNNER: 
          ✅ This is legacy runner (old one) which is provided in SB 1.0 version.
          ✅ It has only one abstract method “run(String… args) : void”.
          ✅ It is a Functional Interface (having only one abstract method).
          ✅ Add one stereotype Annotation over Implementation class level (Ex:- @Component). So that container can detect the class and create object to it.

      🎯 How CommandLineRunner works?
      🔹 CommandLine arguments which are passed to application which will be given to Spring Boot starter main(..) method. 
      🔹 Those are stored as “string Array” (String[]).
      🔹 SpringApplication.run(…) reads this input and internally calls run(..) methods of RunnerImpl classes and pass same data.

    🚀 2 ApplicationRunner(I) :-- 
         ✅ It is new type runner added in Spring boot 1.3 which makes easy to access arguments.
         ✅ This will separate Option Arguments (as Map<String, List<String>>) and Non-Option Arguments (<List<String>)
         ✅ This Data Stored in Object

      🎯 What is the difference between CommandLineArgument and ApplicationRunner?
      🔹 Working process of CommandLineRunner and ApplicationRunner are same, but CommandLineRunner (CLR) holds data in String[] format where as Application (AR) holds data as 
          ApllicationArguments as Option/Non-Option format.

🧠 @ConfigurationProperties:
****************************
  ✅ This Annotation is used to perform bulk data reading (multiple keys at a time) and parsing into one class type (Stores in project).
  ✅ Possible conversions are.
      📌 a> 1key = 1 variable
      📌 b> Multiple keys with index = List/Set/Array
      📌 c> Multiple keys with key-value format = Map or Properties
      📌 d> Multiple keys with common type = Class Object (Has-A)

🧠 pom.xml (Maven Process) :
****************************
✅ Maven is Dependency management and build tool used to handle both stand alone and Archetype (web, restful…) applications.

🧠 Dependency Management:
*************************
✅ Getting Main Jars and its child jars with version support (without conflicts) into project workspace is called as Dependency Management.

🧠 Build:
*********
✅ Converting our application into final JAVA executable format i.e .jar/.war/.ear.

🧠 Major components of pom.xml:
*******************************
  📌 1>  Current Project
  📌 2>  Parent Project
  📌 3>  Dependencies
  📌 4>  Build plugins

🧠 Dependency exclusions:
*************************
✅ When <dependency> tag is added in pom.xml then it will download Parent jars and all its child jars also.
✅ To avoid any one or more child jars from chain, use concept called exclusion.
  Syntax:--
    <dependencies>
     <dependency>
        <groupId>..</groupId>
        <artifactId>..</artifactId>
        <version>..</version>
        <exclusions>
         <exclusion>
           <groupId>..</groupId>
           <artifactId>..</artifactId>
         </exclusion>
       </exclusions>
     </dependency>
    </dependencies>

🧠 Scope (<scope> </scope> in dependency:
*****************************************
✅ For every dependency one scope is given by maven i.e. default scope : compile.
✅ This tag is optional and indicates when a JAR should be used/loaded.

    POM format:
      <dependency>
         <groupId>…</groupId>
         <artifactId>…</artifactId>
         <scope>….</scope>
      </dependency>

Possible Maven dependency scopes are (5) :
  📌 1> compile: A jar Required from compilation time onwards. It is only default scope.
  📌 2> runtime: A jar required when we are running an Application, not before that.
  📌 3> test:    A Jar required only for UnitTesting time.
  📌 4> provided:A jar provided by servers or Frameworks (Container….).
  📌 5> system:  A Jar loaded from File System (like D:/abc/myjar/…)
              =>In this case we should also give <SystemPath> with location of JAR.Ex:-- <systemPath>D:/asf/lib/</systemPath>
      
💡 NOTE:-- 
  ✅ There is a dependency jar which not existing in the maven centre but locally.
      After mvn clean install, this dependency jar can't be found from the fat jar. is this an known-issue? 
      the workaround is have to install it into local maven repo with command:
      `mvn install:install-file -Dfile=lib/routines.jar -DgroupId=org.talend -DartifactId=routines -Dversion=1.0 -Dpackaging=jar`

  ✅ Then using normal dependency format in the pom.xml like this:
   <dependency>
       <groupId>org.talend</groupId>
       <artifactId>routines</artifactId>
       <version>1.0</version>
    </dependency>

🧠 Maven Goals Execution:
*************************
🚀 1> Maven clean:-- It is used to clear target folder in maven project. i.e delete all old files from target.
🚀 2> Maven install :-- It will downloaded all required plugins and also
    => compile the source files.
    => load required properties.
    => Execute JUnit Test cases.
    => Create final build (.jar/.war).

🧠 Use of Starter class:
************************
🚀 1> Define Spring Container.
✅ Spring container holds all required beans (Objects), this is created using Impl class. 
✅ AnnotationConfigApplicationContext (C) for simple (non-server) based application.
✅ For server based Application, Impl class is : AnnotationConfigServletWebServerApplicationContext (C).

🚀 2> Here “Starter class Package” behaves as basePackage, if nothing is provided by programmer.
✅ If Programmer writes externally @ComponentScan then Starter class package never taken as basePackage.
✅ Spring Boot starter class package behaves as base package for componentScan of all classes having annotated with @Component 
    [or its equal].
✅ Annotations are : (class should have any one)
   a> @Component
   b> @Repository
   c> @Service
   d> @Controller
   e> @RestController
   f> @Configuration

🚀 3.> Every Spring Boot Application Starter class itself Component. 
        i.e @SpringBootApplication is having @Component annotation internally.
✅ It is only highest Priority component by default, if app has multiple components.
        Ex:- We can convert starter even as Runner.

🚀 4> Auto-Detect and Execute Configuration classes [Auto-Load Configuration files]
✅ Every Spring Boot starter class itself A configuration class (@Configuration) which auto detects other Config Classes 
    even without @Import annotation.
    i.e. We can define @Bean (Objects creation in Starter class).
✅ All Spring (Java based) Configuration files are loaded into container with @Configuration.
✅ All Spring (java based) Configuration files are loaded into container by spring boot if classes are annotated with @Configuration.
✅ Not required to pass as ApplicationContext input (as like Spring f/w)

*************************************************** SB DATA JPA***************************************************************************************************************************
🧩 ✅ #1:- Data JPA provides @NoRepositoryBean (S) which is auto configured and self logic implemented for basic operations 
    i.e : Programmer not required to write any logic for basic operations (No Implementation class and method)..
✅ Configuration for DataSource (I), SessionFactory (I), HibernateTemplate (C) Hibernate TransactionManger (C) all are not required.
✅ When we add bellow dependency in pom.xml it will download Jars and above Config code given from parent Project.
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>Spring-boot-starter-data-jpa</artifactId>
    </dependency>

🧩 ✅ #2:- Data JPA provides “Embedded Database Support”. It means Database provided in application itself.
✅ It is not required to download and Install, not even properties required (like driver class, url, user, password).
✅ Spring Boot supports 3 Embedded DBs. Those are : H2, HSQLDB, Apache Derby.
✅ We can use any one Embedded Database which runs in RAM (Temp memory).
✅ It uses hbm2ddl.auto=create-drop i.e Tables created when App starts and deleted before App Stops.
✅ These DBs are used in both Development and Testing Environment, but not in Production.
✅ Spring Boot also supports Both SQL (MySQL, Oracle) and NoSQL (MongoDB)Database etc.. also.
✅ Data JPA Supports Special concept “Query Methods an easy way to code and fetch data from DB” (ex : findBy, @Query).
✅ Data JPA supports Easy Connection Pooling (Auto Config) concept.
✅ Data JPA supports Cache Management (AutoConfig)

🧠 Repository Interfaces:
*************************
✅ Data JPA has provided Repository Interfaces in package “org.springframework.data.repository”.
✅ Primary key data Type must be Wrapper class or any other classes which implements java.io.Serializable.
✅ Primitive Types are not accepted as PK DataType for model & for Repository Coding.

🧠 Method Descriptions:
***********************
✅ 1> save (obj) :-- Behaves like save or update, If PK exist in DB table then “UPDATE” else “INSERT”.
✅ 2> findById(ID): Optional<T> :-- It will return one row as one Object based on Primary key in Optional <T> format.
    =>use methods isPresent() to check record is exist or not? If exist use method get() : T to read object.
✅ 3> finadAll () :-- It returns Collection of Objects (=no Of rows in DB Table)
    =>In simple select * from tableName;
✅ 4> deleteById(ID) :-- To delete one Row based on PK.
✅ 5> deleteAll() :-- To delete all Rows [One by one row]
✅ 6> deleteAllInBatch () :-- To delete All rows at a time ex: delete from <tableName>

🧠 2.2 Query Method in Spring Boot Data:
****************************************
✅ Spring Data generates a query based on method written in Repository by Programmer.
Types of Query Methods (3):
🚀 1> findBy
🚀 2> @Query (manual Query)
🚀 3> Special Parameters/ReturnTypes
   
✅ 1. findBy :
⚡ It will generate select query based on abstract method given by programmer. We can provide columns and rows details.
⚡ It will be converted to equal SQL query based on Database at runtime.
⚡ Syntax:--
      RT findBy______(Parameters …);
      Here, RT = ReturnType, ex: List<T>, T, Object, Page<T>, Slice<T>, Object[], Specific Projection etc.

✅ 2. @Query(“hql”):
⚡ This is used to perform (Hibernate Query Language) operations, works for both select and non-select operations.
⚡ To pass where clause inputs use positional parameters in style ?1, ?2, ?3…. Or 
    Named parameters in style [:name]:a, :b, :c, :hello, : mydata
⚡ But variable name must be same as named parameter.
⚡ Providing package name for Model class in @Query is optional. i.e. select p from com.app.model.Product, select p from Product (are same)
⚡ To perform non-select operation define HQL(Query) and apply @Modifying and @Transaction over @Query method.
⚡ @Transaction can be applied over repository method or in service layer method.

✅ 3. PROJECTIONS:  
⚡ By default every Query method (findBy__) return all columns (full loading).
⚡ Here Projections are used to select few columns (variables).
⚡ Projections are two types
   🚀 1. Static Projections      🚀 2. Dynamic Projections

🧠 1. Static Projections:
✅ This concept is used for always fixed types of columns selection for multiple runs (or calls).
✅ Steps to implements static Projections:
⚡ Step#1:- Define one child interface (inner interface) in Repository interface with any name. 
            (OR) Create one public interface & use that inside RepositoryInterface as DataType
⚡ Step#2:- Copy variable equal getter method (getMethods()) from model class to child interface.
⚡ Step#3:- Use that child Interface as ReturnType for findBy() findBy methods.
Format:
  SYNTAX:
  Interface _______Repository extends JpaRepository<…>{
    Interface <childType> {
      DataType getVariable();
      DataType getVariable();
    }
    List<childType>findBy___(…);
  }
  Example:
  @Entity 
  public class Product {
          @Id
          private Integer prodId;
          private String vendorCode;
          private String prodName;
          private Double prodCost;
          //constructors, getter&setters, toString
  }
  
  public interface ProductRepository extends JpaRepository <Product, Integer> {
         interface MyView {
                  //Copy from getter method (RT and methodName)
                  String getVendorCode();
                  String getProdName();
                  Double getProdCost();
          }
          //select code, cost from prodtab where ven_code=?
          List<MyView> findByVendorCode(String vc);
  }
  
🧠 2. Dynamic Projections: 
✅ In this case findBy(___) method return type is decided at runtime (i.e It is Generics)
✅ Format & Syntax: 
    <T> List<T> findBy___(...,Class<T>clz); //fixed Line
    Note:-- Here “T” is child interface type, provide at runtime                                
                
✅ Example:
Entity Class: 
       @Entity 
        public class Product {
                      @Id
                      private Integer prodId;
                      private String vendorCode;
                      private String prodName;
                      private Double prodCost;
                      //constructors, getter&setters, toString
          }
Repo: 
    public interface ProductRepository extends JpaRepository <Product, Integer> {
           //2. Dynamic Projection Code
           interface MyViewTwo {
             //Copy from getter method (RT and methodName)
             Integer getProdId();
             Double getProdCost();
           }
           interface MyView {
                     //Copy from getter method (RT and methodName)
                     String getVendorCode();
                     String getProdName();
                     Double getProdCost();
           }
           //select code, cost from prodtab where ven_code=?
           List<MyView> findByVendorCode(String vc);
    }
Main Method:
    repo.findByVendorCode("V3",MyViewTwo.class).stream().map((ob)->ob.getProdId()+","+ob.getProdCost()).forEach(System.out::println);

⚡ Note:--
🔹 Dynamic Projections are slow compare to static Projections.
🔹 For dynamic Projections “Type selection, validate and execution” done at Runtime, where as for static select and validate done at 
    compile time, only execution done at runtime.
🔹 Static Projections also called as compile time (selected) Projections and Dynamic Projections also called as Runtime (selected) 
    Projections.

🧠 Special Types in Query methods:
**********************************
🚀 1. Page<T>
🚀 2. Slice<T>
🚀 3. Stream<T>

These are Special type outputs for Query methods to get “Pagination data”.
 ✅ 1. Streamable(I):-- It will help to return Collection data (one page only) in Stream<T> (java.util) format,
        where we can apply functions like filter, sort, map and collect…etc
 ✅ 2. Slice(I):-- It is used to provide current page data and links with previous and next page details ** 
        It never holds all pages details like total no.of pages and total Elements.
 ✅ 3. Page(I):-- It is extension to Slice and holds even total no.of pages (links to other pages) and 
        total Elements (total rows details)

    Page(and Slice):
    ***************
      Step#1:- Insert few records in db (ex; 20 Rows).
      Step#2:- Define a Repository method with parameter must be Pageable (as last param).
        Ex:-Page<Product> findByVendorCode (String vc, Pageable pageable);
      Step#3:- In Runner class call method and print details like, isEmpty?, first?, last?....etc 
                Streaming:-- Streaming is process of Read  filter  sort  map  collect
      =>Over collection data which uses Streams concept given in JDK 1.8.
      =>Streams are used to execute series of operations in one or less Iterations, which reduces execution time to normal programmer 
        iterations.
  ✅ 4. Connection Pooling in SpringBootData:
      🔹 SpringBoot 1.X works on Tomcat Connection pooling as default and Boot2.X works on Hikari connection pooling which is very 
          fast in service.
      🔹 This is not required to be configured by developer. By default spring boot configures using class input “HikariConfig” 
        with all default values (milli sec time).
      🔹 To provide Programmer specific values use key spring.datasource.hikari.* in 
      🔹 application.properties.
          spring.datasource.hikari.connection-timeout=20000
          spring.datasource.hikari.minimum-idle=5
          spring.datasource.hikari.maximum-pool-size =12
          spring.datasource.hikari.idle-timeout =300000
          spring.datasource.hikari.max-lifetime =12000
          spring.datasource.hikari.auto-commit =true


********************************************************** SB WEB MVC ******************************************************************************************************************
1. Introduction:
================
  => Spring Boot has provided one starter for web application. 
  => It is similar to spring WEB MVC execution process but reduces work done by programmer for,
   a. Maven project creation and setup.
   b. Pom.xml dependencies and plugins.
   c. Writing common code (AppInit, AppConfig).
   d. Handle Runtime Environment and creating JAR/WARs.
  => Such process is taken care by spring boot and called as “AutoConfiguration”.
  => Even coming to Handler Mapping is configured by FC.
  => ViewResovler needs not to be configured. But Programmer has to provide (Prefix and Suffix) using properties/yml file.
  => FC (DispatcherServlet) is configured by spring boot and mapped to URL = “/”.
  =>FC, ViewResolver, HandlerMapper taken care by Boot, Controller and UI files should be defined by Programmer.
    Data Rendering:-- Reading data from Model (I) or ModelMap(C) at runtime and send to UI is known as Data Rendering, It is implemented using 
                      EL Programming.
      =>Programmer should provide inputs like port number view resolver details using Properties or yml file. Example files like
      application.properties:--
        server.port=9898
        spring.mvc.view.prefix=/WEB-INF/views/
        spring.mvc.view.suffix=.jsp
      =>Default port no mapped to ‘8080’ by using key ‘server.port’. We can change even.
      =>Spring boot has provided 3 embedded servers. [No download and No install]
      Those are : Tomcat (default server), Jetty and Undertow.
      =>In General Tomcat container 2 engines Servlet Engine (Catalina) and JSP Engine (JASPER). In Spring boot, tomcat comes with only Servlet 
        engine. That’s why it is also called as light weight engine that works for “DispatcherServlet”, nothing else.
      => Default Static Resource Handler is added to folder static and template which are provided under src/main/resources folder.
      =>To work with JSP files in Spring Boot WEB apps, we need to add dependencies in pom.xml.
        <dependency>
         <groupId>org.apache.tomcat.embed</groupId>
         <artifactId>tomcat-embed-jasper</artifactId>
         <scope>provided</scope> //Version taken care by Spring boot (and Tomcat)
        </dependency>
      => To avoid/remove tomcat server (default server) from Boot application, we need to add <Exclusion> for Tomcat under web dependency. 
          Given as,
        <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-web</artifactId>
          <exclusions>
            <exclusion>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-tomcat</artifactId>
            </exclusion>
           </exclusions>
          </dependency>

        => To use jetty in spring boot, first we need to exclude ‘tomcat’, then add below dependency in pom.xml.
          <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jetty</artifactId>
          </dependency>
        => In case of ‘JBoss Undertow Server’ add below dependency.
          <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-undertow</artifactId>
          </dependency>
        => Tomcat provided by Apache.
        => Jetty Provided by Eclipse.
        => Undertow provided by JBoss.
        => Final packing of Spring Boot Application: after coding and unit testing, our project will be converted to JAR/WAR based on <packing> 
          type selected while creating project.
        Execute commands:-
        Step#1:- Do JDK setup.
        Step#2:- Clear target folder.
        Step#3:- Generate jar/war file.
        => Refresh target folder after message “build success”. 
        => If pom.xml contains <packing>war</packing> then it will be converted to [ProjectName]-[version].war 
        => Else it is considered as jar[ProjectName]-[version].jar
        => To indicate Spring container, spring f/w has provided two container interfaces. 
        Those are.
         a. BeanFactory (I) [Legacy]
         b. ApplicationContext (I) [new]

        => In Spring boot programming, for stand-alone type application impl class used “AnnotationConfigApplicationContext”.
        => For Spring Boot web and related application impl class used: “AnnotationConfigServletWebServerApplicationContext”.
        => In case of Spring Application for web Programming Programmer has to define 
        Configuration code as.
        Ex:--
          @Configuration
          @ComponentScan (basePackage=”---“)
          public class AppConfig {----}
          => Here, basePackage must be provided by programmer. If we are using Spring boot then ‘basePackage’ is set to Spring Boot Starter class 
              package.
          => All our classes which are annotated with StereoType annotation must be under starter class package or its sub package.
          => All our classes which are annotated with stereotype annotations must be under starter class manually. It is not a good approach.
          => We can run Starter class only one time if type is web application with one port number.
          =>If we want to run again, then must stop last process which is already running.
           -> Goto Console option.
           -> Look at Console Symbol.
           -> Click on DropDown (In case of multiple).
           -> Click on Red Color Box Symbol (Stop Symbol).

        =>URL gets changed from server to server where as URI remains same.
        =>If URL doesn’t contain any PORT number then default mapped to ‘80’ [HTTP Default port number].
        Ex:-- http://locahost/MyApp/show
        -> In above example PORT number is : 80
        ***It means if server is running on PORT number: 80, then PORT number not required to write in URL.

Q>What is the difference between Model (I) and ModelMap (C) ?.
A> ModelMap:-- It is a shared Memory holds data in key=val which allocates memory based on data added to it In simple onDemand Memory Creation.
B> Model:-- Model also similar to ModelMap, but un-used key=val pairs (at UI) are removed from memory.
NOTE:-- In above example “AppInt” and AppConfig” are provided by spring Boot.Annotation like @EnableWebMvc, @ComponentScan, @PropertySource not required to provide.

2. Hot Deployment using DevTools:--
  =>If we do any modification in application files after starting server, Boot will not update them into server (war/jar) unless we started i.e. to see changes “STOP and START” 
    server again.
  =>To avoid this process “Spring Boot DevTools” are introduced which runs as parallel execution and links to war file.
  =>It is also called as HotDeployment/ HotSwapping. This process is used only to save development time not recommend using in Production.
  =>DevTools executions LiveReload in server on port 35729
  Dependency:--
    <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-devtools</artifactId>
     <scope>runtime</scope>
    <dependency>
  =>Choose Spring DevTools while creating your project.
  Deployment:-- Place jar/war in server and start server
  HotDeployement:-- Without stopping server, update only new files into jar/war which is in server.
  NOTE:--
  1. To change PORT Number use key spring.devtoolds.liveload.port=---
  2. By default few files are not re-loaded by devTools Given using key “spring.devTools.restart.exclude” 
  Locations are:-
  META-INF/maven/** META-INF/resources/**,
  resources/** static/**,
  public/** template/**,
  **/*Test.class **/*Tests.class,
  git.properties, META-INF/build-info.properties
  1. To avoid extra files which need to be re-loaded can be given key (with example values) spring.devtools.restart.additional-exclude=/sample/app.properties
  =>To specify location which need to be included for re-loading (key-val example) use 
  key: spring.devtools.restart.additional-paths=static/**, templates/**

4. Cache Management in Spring Boot:
===================================
=>Cache is Temp memory used at application side to reduce network calls between Application and Database for commonly accessed data.
=>Caches are used to save time for network calls that improves the app performance.
=>Cache should never hold large data, apply only for few modules which are accepted more times by client.
***Do’t apply cache for findAll() type method
=>To implement Cache Management in Spring Boot Application. We should use any one vendor. ex: HazelCast Cache
=>First, we need to indicate “Create Cache Memory at application side, using class Config (com.hazelcast.config)”.
***This Cache Memory can also be called as “HazelCast Instance”.
=>To enable cache for one module, use MapConfig(C) object and provide details like “name, lifeTime, cacheSize, Eviction…” one time.
=>This MapConfig (C) can be repeated for multiple module [i.e one module = one MapConfig object].
=>MapConfig stores data in key=val format Here key=PrimaryKey (ID) and val=Model class object.
=>EvictionPolicy is an enum defined with Eviction possible values. It means removing one object from cache based on Condition.
=>EvictionPolicy Possible values and meaning are.
   LRU:- Least Recently used.
   LFU:- Least Frequently Used.
   NONE:- Don’t remove any Object.
   RANDOM:- Any one Object
  Frequency:-- No. of times object is accessed.
  Recent:-- Which is seen last in order (or) latest object
  =>Here, Config is used to create Cache Instance where as MapConfig is used to module memory. Example, looks like below.
  Hazelcast-cache Config :-- It is a 3rd party Cache configuration process, supported for any java application caching

Step#1:- Provide Dependencies for Starter-cache, HazelCast and Hazelcast-spring integration.
=>Choose Spring cache abstraction dependency
<dependency>
 <groupId>org.springframework.boot</groupId>
 <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
<dependency>
 <groupId>com.hazelcast</groupId>
 <artifactId>hazelcast</artifactId>
</dependency>
<dependency>
 <groupId>com.hazelcast</groupId>
 <artifactId>hazelcast-spring</artifactId>
</dependency>

Step#2:- On starter class level we need to specify enable annotation for Cache Management. @EnableCaching
Step#3:- Model class which needs cache support must implement one interface
java.io.serializable
Ex:-- class Employee implements Serializable { }

Step#4:- Define Java config class for HazelCast Cache Configuration and MapConfig 
Objects code looks like:
=> In application write Java configuration code for Config (C) (com.hazelcast).

Step#5:- At service Layer methods need to apply cache annotation given by spring.
 a. @Cacheable:- This one must be applied over select method (getOneById).
 b. @CacheEvict:- This one must be applied over delete method (deleteById).
 c. @CachePut:- CachePut annotation is used to update object in cache before
 updating in Database.
A >Over getOne (findOne) method @Cacheable(value=”cache-name”, key=”#PKId”)
b>Over delete method (delete byId) @CacheEvict(vale=”cache-name”, key=”#PKId”)
------Example service layer methods with cache annotation:-----
@Service
public class Employee {
@Cacheable (value="emp-cache", key="#empId")
public Employee getOneEmployee(Integer empId) {
//select * from empTab where eid=?
}
@CacheEvict(value="emp-cache", key="#empId")
public void deleteById(Integer empId) {
//delete * from emptab where eid=?
}}

1>@CacheEvict :-- This annotation is used to remove object from cache (not from DB).
=>On calling service.delete..() method, SQL query delete row only in DB but not in 
cache.
=>At same time object to be removed from cache, for that add this Annotation over 
delete(..) method in service layer

2>@Cacheable :-- On calling select… SQL (load one row as object) same object will be 
placed in cache before give to Service (App).
3> CachePut:-- This annotation is used to update object in cache before updating in 
Database.
NOTE:--
 Define one MapConfig memory for one module cache.
 new MapConfig().setName(“prod-cache”);
 Provide MAX size of cache (maximum no. of objects to be hold by cache)
 setMaxSizeConfig(new MaxSizeConfig(100, MaxSizePolicy.FREE_HEAP_SIZE))
 Provide EvictionPolicy.
 **If cache is full and another object is in waiting state to get into cache then
 EvictionPolicy will not allow another obj. (Default is : NONE).
 **EvictionPolicy .LRU : Will remove last accesses Object (Least Recently Used) 
 from cache.
 Provide Life Time of object to be in cache (in second)
 setTimeToLiveSeconds (3000);

Log4j.properties:
=> This file is used to provide all the configuration details of Log4J. Especially like appender and layout details with Pattern and also root Logger details. 
=>We should not create Appender in every class only logger object must be created in a class.
=>Data will be shown in below order like
 1. rootLogger
 2. appenders
 3. layouts
 Appender name must be defined before use at rootLogger level.
 We can specify multiple appenders in log4j.properties file like 2 File Appenders, one JdbAppender, one smtpAppender etc…
 Appender name can be any think ex:-- abc, hello, sysout, file, db, email etc…
 log4j.properties file must be created under src/main/resource folder (Maven).
 Make rootLogger =OFF to disable log4j completely without deleting code in any class or properties file.
 log4j.properties file will be auto detected by log4j tool. No special coding is required.
Format : Log4j.properties
log4j.rootLogger=PRIORITY, APPENDER NAMES, ….
log4j.appender.<name>.layout=…..

VM Arguments:-- A variable created with value at JVM level which can be stored to one or services (Projects/Threads/Apps… etc) Format for creating System / VM Argument -Dkey = value =>To read data in Application code is : 
String s = System.getProperty(“key”);
2. Working with logging using spring boot:--
Step#1:- Creating logger object using multiple APIs.
a>SLF4J API:--
 private static Logger log = LoggerFactory.getLogger(----.class);
b>Apache Log4J:--
 private static Logger log = LogManager.getLogger(----.class);
c>Java util Logging 
 private static logger log = LogManager.getLogger(---.class, getName());
Step#2:- Provide Appender and Layout details using Properties files/yml file in Boot.
NOTE:- Application No need to create another log4j.properties file.
=>Default logging level in INFO.
Example:-- key = value pairs are given below.
application.properties:--
logging.level.root=INFO
logging.file=d://logs/my.log
logging.level.org.springframework=error
logging.pattern.file=%p %d{dd-mm-yy}%L %c[%m]-%d %n
logging.pattern.console=%d{yyyy-mm-dd HH:mm:ss}-%m %n


5. Lombok API:--
=>This is open source JAVA API used to avoid writing (or generating) common code for 
Bean/Model/Entity classes.
That is like: 
1.>Setters and Getters
2.>toString() method
3.>Default and Parameterized Constructor
4.>hashCode() and equals() methods.
=>Programmer can write these methods manually or generate using IDE. But if any 
modification (s) are done in those classes then again generate set/get methods also 
delete and write code for new : toString, hashCode, Equals and Param const (it is like 
represented task).
=>By using Lombok API which reduces writing code or generating task for Beans.
Just apply annotations, it is done.
=>To use Lombok, while creating Spring Boot Project choose Dependency : Lombok (or) 
Add below dependency in pom.xml.
(for Spring Boot Project: Do not provide version provided by spring boot Parent only.)
<dependency>
<groupId>org.projectlombok</groupId>
<artifactId>lombok</artifactId>
<optional>true</optional>
</dependency>
<dependency>
 <groupId>org.projectlombok</groupId>
 <artifactId>lombok</artifactId>
 <scope>provided</scope>
</dependency>
NOTE:-- (For Non Spring Boot Projects)
<dependency>
 <groupId>org.projectlombok</groupId>
 <artifactId>lombok</artifactId>
 <version>1.18.6</version>
</dependency>

6. Logging:-- This process is used to track all types of messages when any request is 
processed by server.
=>Here tracking means, finding messages like SUCCESS, WARNING, EXCEPTIONS, (N/W, 
DB…), INFORMATIONS… etc.
Types of server:--
a. DEV / QA Server
b. UAT Server (User Acceptance Test):- Client does testing before purchase the 
project/product.
c. Production Server :-- Application placed in real-time server and this can be 
accesses by end users.
d. MS service (Management Support).
=>To implement Loggin concept, we need to provide 3 components. Those are:
a>Logger (C) 
b>Appender (I)
c>Layout (AC)
a>Logger:-- This object need to be created in class which needs Logging concept.
=>If Logger object is created then Logging is enabled for that class, else not.
=>All classes may not need Logger object, Example Model class.
=>Logger object can be created using Different Vendors few are: Apache Log4J, SELF4J, 
Java UTIL Logging, JBoss Logging, Apache JCL (Commons Logging)…etc.

b>Appender :-- It indicates where to store Log messages Possible Appender are.
 1>ConsoleAppender (C)
2>FileAppender *** (C)
3>SmtpAppender (C)
4>TelnetAppender (C)
5>JdbcAppender (C)
=>FileAppender is mostly used one for projects which stores all log messages in 
---.log file.
c>Layout:-- This one used to specify “Message Format” to be printed on Appender.
=>PossibleLayouts are / implemented classes are.
 1>SimpleLayout:- Prints only message as it is provided in log methods.
 2>XMLLayout:- Converts message into XML Format.
 3>HTMLLayout:- Prints in HTML format.
 4>PatternLayout:- Programmer can define Message Format (like Date-Time-class-
 method-line-message ... etc).
=>For more details about pattern visit bellow link :
https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html
NOTE:-- In one Application we can use more than one Appender also.
=>In development mostly used Appender is FileAppender and Layout is Pattern Layout.
=>If No appender is provided to Logger object then Log4J throws WARNING as log4j : 
WARN No appenders could be found for logger (com.app.Product).
=>At last Appender object must be added to Logger Object then only it is considered 
by using log.addAppender() method.
Priority Methods with Order:--
=>This are used to print log messages with type indications.
=>List of Methods with order is given below.
Order Method Meaning
1 TRACE =>State of execution.
2 DEBUG =>Message with final Result.
3 INFO =>Message of current step
4 WARN =>Warning message.
5 ERROR =>Exception messages.
6 FATAL =>High Level Exceptions/ Errors
0 OFF =>Do TURN OFF Logging


***************************************** SB REST (Provider & Consumer) ***********************************************************************
1. Introduction:--
=> To implement ReSTFul webservices API using simple annotations and Templates Spring boot ReST F/w has been introduced.
=> Even to implement Microservices design Spring boot ReST API is used.
NOTE:
a.> Consumer and Provider interchanges the data Primitive (String format only), Class Type (Object) and Collections.
b.> Data will be converted to either JSON or XML format also known as Global Formats
c.> String data will be converted to any other type directly.
d.> ReST Controller supports 5 types of Request Methods Handling. Those are HTTP Method : GET, POST, PUT, DELETE and PATCH.
e.> Controller class level use annotations @RestController (Stereotype), @RequestMapping (for URL).
f.> Controller methods level use annotations.
TYPE             Annotations
GET              @GetMapping
POST             @PostMapping
PUT              @PutMapping
DELETE           @DeleteMapping
PATCH            @PatchMapping
g.>To provide Inputs to Request Methods in RestController, use annotations.
TYPE               Annotation
url?key=val        @RequestParam
/url/val/          @PathVariable
/url/key=val       @MatrixVariable
Http Header        @RequestHeader
Http Body          @RequestBody
***All above annotations works on HttpRequest only, supports reading input data.
h.> By default Matrix Parameter is disabled (may not work properly). To enable this write below code in MVC config file.
i.> DispatcherServlet is autoConfigured in Spring Boot with URL Pattern mapped to /.
j.> AutoConfiguration Provided even for @EnableWebMvc, @ComponentScan(Startsclass), @PropertySource(“ClassPath:application.propery”)
k.> Embedded server.
NOTE:--
a. URL is case-sensitive, same URL can be used at multiple (GET, POST, PUT…) must be different.
b. Difference between PUT and Patch :
PUT :-- It indicates modify complete (full) data, based on Identity (ID-PK).
PATCH :-- It indicates modify partial (few data, based on Identity (ID-PK).

Example#2 Read Data from Http Request (Head and Body).
=> Http Request sends data using Header and body Section (both).
=> To Read any Header Parameter use code
 @RequestHeader DataType localVariable
 @RequestHeader (required=false) DataType localVariable
 @RequestHeader (“key”) DataType localVariable
=> To read data from Body (RAW Data) use code @RequestBody
NOTE:--
 Request Header is required (true) by default to make it optional, add code required=false.
 If key name localVariable Name same then providing key name is optional.
 Request Body Raw data (Characters or any…).
 Can be Stored in String with any variableName.
2. Passing Input to RestController:--
=> RestController will read input data either in primitive or in Type (Object/Collection).
=> To pass data/input to rest controller Spring has provided different concepts.
Those are :--
1> Request Header
2> Request Body ***
3> Request Parameter
4> Path Variable ***
5> Matrix Variable (disable mode by default)

1> Request Header:-- It provides data in key=value format (both are String type).
=> Request header also called as Header Parameters.
=> These are used to provide instructions to server (application/Controller).
Ex:-- Content-Type, Accept, host, Date, Cookies…

2>Request Body:-- To send large/bulk data like objects and collections data in the form of JSON/XML.
=> Even supported large text (Raw data).
=> Spring boot enables JSON conversion by default, but not XML (no JAXB API).

3>Request Parameter:-- To pass primitive data (like id, name, codes … etc) as input, request parameters are used.
=> format looks like url?key=val&key=val…
=> Both key and value are String type by default.
Request Parameter: Format:--
@RequestParam(value="key", required=true/false, defaultValue="-value-")
DataType localVariable

Syntax #1:-
@RequestParam("key") DataType localVariable
Ex#1: @RequestParam("sname") String sn

Syntax #2:-
@RequestParam DataType localVar
Ex#2: @RequestParam String sname
=>If key name and local variable name are same then key is not 

Syntax #3:-
@RequestParam(required=false) DT localVariable
=>To make key-value is optional @RequestParam (required=false) String sname

Syntax #4:-
@RequestParam (required=false, defaultValue="-DATA-")DT localVariable
=>To change default value from null to any other value.
@RequestParam(required=false, defaultValue="No DATA") String sname

Paths are two types:--
a.>Static Path [format:/url]
b.>Dynamic Path [format:/{key}]
=> Static Path indicates URL, where as Dynamic Path indicates Data at runtime.
=> While sending data using Dynamic Path key should not be used. Only data
=> Order must be followed in case of sending multiple Parameters.
=> To read data at controller method, use annotation : @PathVariable.
Syntax:--
@PathVariable datatype keyName

3. RestController : Method ReturnType:--
=> We can use String (for primitive Data), A classType or Any CollectionType(List, Set, Map…) as Method ReturnType.
=>If return types String then same data will be send to Controller.
=>If return type is non-String (Class or Collection Type) then Data converted to Global Format (ex: JSON/XML).
=>Default conversion Type supported by Boot is JSON (Java Script Object Notation).
=>Even “ResponseEntity<T>” can be used as Return Type which holds Body (T) and status (HttpStatus enum).
Possible Http Status are (5):
Code        Types
1xx         Informational
2xx         Success
3xx         Redirect
4xx         Client Side Error
5xx         Server Side Error
=> To Convert Object to JSON (and JSON to Object) SpringBoot uses JACKSON API.Spring Boot ReST + Data JPA +MySQL CRUD Operations (Rest API with Swagger):--
=> Here, define ReST Collector which works for JSON and XML Data input/output.
=> For Primitive inputs use PathVariable.
=> ReST Controller must return output type as ResponseEntity<T> which holds Body(T) and HttpStatus Ex:-- 500, 404, 200, 400 etc..

Operation Type Http Method Annotation
Save         @PostMapping
Update       @PutMapping
Delete       @DeleteMapping
getOne       @GetMapping
get all      @GetMapping

MediaType Conversion annotations are:--
=> @RequestBody and @ResponseBody are the MediaType annotations.
=> Here, @ResponseBody is applied when we write @RestController annotation over class (**Not handled by programmer). 
  It converts Class/Collection type to JSON/XML.
=> @RequestBody should be handled by programmer. It converts JSON/XML Data to Object format.
NOTE:-- If request Id is not present then Return Http Status – 400 BAD-REQUEST
4. Enable Swagger UI in Spring Boot ReST Application:--
=> Compared to all other tools Swagger is a RichSet API provides dynamic UI based on code written for Rest Controller with common Paths.
Step#1:- Add below dependencies in pom.xml
<dependency>
 <groupId>io.springfox</groupId>
 <artifactId>springfox-swagger2</artifactId>
 <version>2.7.0</version>
</dependency>
<dependency>
 <groupId>io.springfox</groupId>
 <artifactId>springfox-swagger-ui</artifactId>
 <version>2.7.0</version>
</dependency>
Flow Meaning
->Docket ()             =>Create Docket
->select ()             =>Choose Rest classes
->apis(basepackage())   =>Classes are in package
->paths (regex())       =>Having common path
->build()               =>Create final output
